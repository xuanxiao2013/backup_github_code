 1.插入排序(Insertion Sort)
 基本思想：每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序；直到待排序数据元素全部插入完为止。
 
 2.选择排序
 基本思想：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 
 
 3.冒泡排序(BubbleSort)
 基本思想：两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。
 
 4.快速排序（Quick Sort）
 基本思想：在当前无序区R[1..H]中任取一个数据元素作为比较的"基准"(不妨记为X)，
 用此基准将当前无序区划分为左右两个较小的无序区：R[1..I-1]和R[I+1..H]，且左边的无序子区中数据元素均小于等于基准元素，
 右边的无序子区中数据元素均大于等于基准元素，而基准X则位于最终排序的位置上，即R[1..I-1]≤X.Key≤R[I+1..H](1≤I≤H)，当R[1..I-1]和R[I+1..H]均非空时，
 分别对它们进行上述的划分过程，直至所有无序子区中的数据元素均已排序为止。
 
 5.堆排序(Heap Sort)
 基本思想：堆排序是一树形选择排序，在排序过程中，将R[1..N]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。

//==============================================================================================================================

一、冒泡排序：
原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。
要点：设计交换判断条件，提前结束以排好序的序列循环。

二、简单选择排序：
原理：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，使得有序区扩大一个，循环最终完成全部排序。

三、直接插入排序：
原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。
要点：设立哨兵，作为临时存储和判断数组边界之用。

四、希尔排序：
原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。
要点：增量的选择以及排序最终以1为增量进行排序结束。

五、堆排序：
原理：利用大根堆或小根堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。
要点：建堆、交换、调整堆

六、归并排序：
原理：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。
要点：归并、分治

七、快速排序：
原理：快速排序采用了一种分治的策略，通常称其为分治法，其基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
快速排序的具体过程如下：
第一步，在待排序的n个记录中任取一个记录，以该记录的排序码为准，将所有记录分成两组，第1组各记录的排序码都小于等于该排序码，第2组各记录的排序码都大于该排序码，并把该记录排在这两组中间。
第二步，采用同样的方法，对左边的组和右边的组进行排序，直到所有记录都排到相应的位置为止。

//==============================================================================================================================


1.普及一下排序稳定，所谓排序稳定就是指：如果两个数相同，对他们进行的排序结果为他们的相对顺序不变。例如A={1,2,1,2,1}这里排序之后是A = {1,1,1,2,2} 稳定就是排序后第一个1就是排序前的第一个1，第二个1就是排序前第二个1，第三个1就是排序前的第三个1。同理2也是一样。这里用颜色标明了。不稳定呢就是他们的顺序不应和开始顺序一致。也就是可能会是A={1,1,1,2,2}这样的结果。
2.普及一下原地排序：原地排序就是指不申请多余的空间来进行的排序，就是在原来的排序数据中比较和交换的排序。例如快速排序，堆排序等都是原地排序，合并排序，计数排序等不是原地排序。
3.感觉谁最好，在我的印象中快速排序是最好的，时间复杂度：n*log(n)，不稳定排序。原地排序。他的名字很棒，快速嘛。当然快了。我觉得他的思想很不错，分治，而且还是原地排序，省去和很多的空间浪费。速度也是很快的，n*log(n)。但是有一个软肋就是如果已经是排好的情况下时间复杂度就是n*n,不过在加入随机的情况下这种情况也得以好转，而且他可以做任意的比较，只要你能给出两个元素的大小关系就可以了。适用范围广，速度快。
4.插入排序：n*n的时间复杂度，稳定排序，原地排序。插入排序是我学的第一个排序，速度还是很快的，特别是在数组已排好了之后，用它的思想来插入一个数据，效率是很高的。因为不用全部排。他的数据交换也很少，只是数据后移，然后放入要插入的数据。（这里不是指调用插入排序，而是用它的思想）。我觉得，在数据大部分都排好了，用插入排序会给你带来很大的方便。数据的移动和交换都很少。
5.冒泡排序，n*n的时间复杂度，稳定排序，原地排序。冒泡排序的思想很不错，一个一个比较，把小的上移，依次确定当前最小元素。因为他简单，稳定排序，而且好实现，所以用处也是比较多的。还有一点就是加上哨兵之后他可以提前退出。
6.选择排序，n*n的时间复杂度， 稳定排序，原地排序。选择排序就是冒泡的基本思想，从小的定位，一个一个选择，直到选择结束。他和插入排序是一个相反的过程，插入是确定一个元素的位置，而选择是确定这个位置的元素。他的好处就是每次只选择确定的元素，不会对很多数据进行交换。所以在数据交换量上应该比冒泡小。
7.插入排序，选择排序，冒泡排序的比较，他们的时间复杂度都是n*n。我觉得他们的效率也是差不多的，我个人喜欢冒泡一些，因为要用它的时候数据多半不多，而且可以提前的返回已经排序好的数组。而其他两个排序就算已经排好了，他也要做全部的扫描。在数据的交换上，冒泡的确比他们都多。呵呵。举例说明插入一个数据在末尾后排序，冒泡只要一次就能搞定，而选择和插入都必须要n*n的复杂度才能搞定。就看你怎么看待咯。
8.合并排序：n*log(n)的时间复杂度， 稳定排序，非原地排序。他的思想是分治，先分成小的部分，排好部分之后合并，因为我们另外申请的空间，在合并的时候效率是0(n)的。速度很快。貌似他的上限是n*log(n)，所以如果说是比较的次数的话，他比快速排序要少一些。对任意的数组都能有效地在n*log(n)排好序。但是因为他是非原地排序，所以虽然他很快，但是貌似他的人气没有快速排序高。
9.堆排序：n*log(n)的时间复杂度， 非稳定排序，原地排序。他的思想是利用的堆这种数据结构，堆可以看成一个完全二叉树，所以在排序中比较的次数可以做到很少。加上他也是原地排序，不需要申请额外的空间，效率也不错。可是他的思想感觉比快速难掌握一些。还有就是在已经排好序的基础上添加一个数据再排序，他的交换次数和比较次数一点都不会减少。虽然堆排序在使用的中没有快速排序广泛，但是他的数据结构和思想真的很不错，而且用它来实现优先队列，效率没得说。堆，还是要好好学习掌握的。
10.希尔排序：n*log(n)的时间复杂度(这里是错误的，应该是n^lamda(1 < lamda < 2), lamda和每次步长选择有关。)， 非稳定排序，原地排序。主要思想是分治，不过他的分治和合并排序的分治不一样，他是按步长来分组的，而不是想合并那样左一半右一半。开始步长为整个的长度的一半。分成nLen/2个组，然后每组排序。接个步长减为原来的一半在分组排序，直到步长为1，排序之后希尔排序就完成了。这个思路很好，据说是插入排序的升级版，所以在实现每组排序的时候我故意用了插入排序。我觉得他是一个特别好的排序方法了。他的缺点就是两个数可能比较多次，因为两个数据会多次分不过他们不会出现数据的交换。效率也是很高的。
11.快速排序，堆排序，合并排序，希尔排序的比较，他们的时间复杂的都是n*log(n)，我认为在使用上快速排序最广泛，他原地排序，虽然不稳定，可是很多情况下排序根本就不在意他是否稳定。他的比较次数是比较小的，因为他把数据分成了大和小的两部分。每次都确定了一个数的位置，所以理论上说不会出现两个数比较两次的情况，也是在最后在交换数据，说以数据交换上也很少。合并排序和堆排序也有这些优点，但是合并排序要申请额外的空间。堆排序堆已经排好的数据交换上比快速多。所以目前快速排序用的要广泛的多。还有他很容易掌握和实现。
12.计数排序：n的时间复杂度，稳定排序，非原地排序。他的思想比较新颖，就是先约定数据的范围不是很大，而且数据都是整数(或能定位到整数)的情况，然后直接申请一个空间。把要排序的数组A的元素值与申请空间B的下标对应，然后B中存放该下标元素值的个数，从而直接定位A中每个元素的位置。这样效率只为n。因为比较很特殊，虽然很快，但是用的地方并不多。
13.基数排序：n的时间复杂度，稳定排序，非原地排序。他的思想是数据比较集中在一个范围，例如都是4位数，都是5位数，或数据有多个关键字，我们先从各位开始排，然后排十位，依次排到最高位，因为我们可以用一个n的方法排一位，所以总的方法为d*n的复杂度。关键字也一样，我们先排第3个关键字，在排第3个关键字，最后排第一个关键字。只有能保证每个关键字在n的时间复杂度完成，那么整个排序就是一个d*n的时间复杂度。所以总的速度是很快的。不过有一点就是要确保关键字能在n的时间复杂度完成。
14.桶排序：n的时间复杂度，稳定排序，非原地排序。主要思路和基数排序一样，也是假设都在一个范围例如概率都在0-1，而且分布还挺均匀，那么我们也是和基数排序一样对一个数把他划分在他指定的区域。然后在连接这些区域就可以了。书上对每个区域使用链表的存储，我认为在寸小区域的时候也会有时间在里面。所以只是理论上的n时间复杂度。这种思路是不错的。呵呵。
15.计数排序，基数排序，桶排序的比较，我觉得他们都很有思想，不过都是在特定情况下才能发挥最大的效果。虽然效率很高，但是用的不会很广泛。他们之间我更喜欢计数排序，来个映射的方式就直接找到了自己的位置，很高明。和基数排序和同排序只是理论上的n时间复杂度，基数排序要确定一个关键字的排序是n复杂度的，桶排序要确定每个区域的排序是n复杂度的。
16.排序算法的最后感悟：黑格尔说过：存在即合理。所以这些排序的算法都是很好的，他确实给了我们思想上的帮助。感谢前人把精华留给了我们。我得到的收获很大，总结一下各自排序的收获：

冒泡：好实现，速度不慢，使用于轻量级的数据排序。
插入排序：也使用于小数据的排序，但是我从他的思想中学到怎么插入一个数据。呵呵，这样就知道在排好的数据里面，不用再排序了，而是直接调用一下插入就可以了。
选择排序：我学会了怎么去获得最大值，最小值等方法。只要选择一下，不就可以了。
合并排序：我学会分而治之的方法，而且在合并两个数组的时候很适用。
堆排序：可以用它来实现优先队列，而且他的思想应该给我加了很多内力。
快速排序：本来就用的最多的排序，对我的帮助大的都不知道怎么说好。
希尔排序：也是分治，让我看到了分治的不同，原来还有这种思想的存在。

计数排序，基数排序，桶排序：特殊情况特殊处理。

//==============================================================================================================================

 直接插入排序:每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。
 二分插入排序（又称折半插入排序）:
 链表插入排序: 静态链表插入排序(List Insertion Sort)算法是直接插入排序的一个变种。它的改进目的是减少在直接插入排序中的移动次数（当然这个改进并没有降低复杂度，仍为O(n^2）)，因此在原 输入数据的基础上附加了一个静态链表（为了减少空间的消耗，静态链表实际上就是用等长的下标数组link来模拟的，而不需要建立一个等长的动态链结构）。 该算法的缺点是：虽然减少了移动次数，但是需要增加一个等长度的link数组，所以也是用空间换取时间的做法。
 希尔排序: 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”
